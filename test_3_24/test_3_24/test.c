#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>
#include <math.h>
#include <string.h>
//int mian()
//{
//	char c = 'w'; //char到底是signed char 还是unsigned char是不确定的，取决于编译器的实现
//	signed char c2 = 't';
//
//	short int a = 10; //short短整型，int可以省略
//	short b = 20; //short是signed short
//
//	signed short c = 30;
//	unsigned short d = 40;
//
//	return 0;
//}

//int mian()
//{
//	int a;
//	int arr[10];//10个整形的数组
//	char ch[5]; //5个字符的数组
//
//	return 0;
//}

//int main()
//{
//	int a = 3;
//	int b = -1;
//	int c = 0x11223344;
//	return 0;
//}


//原码 - 有符号数，直接根据正负数值给出的二进制序列就是原码
//反码 - 原码的符号位不变,其他位按位取反
//补码 - 反码二进制的最低位+1得到

//正数的原码、反码、补码相同
//int main()
//{
//	int a = 3;    //signed int a = 3;
//	00000000000000000000000000000011         - 原码
//	00000000000000000000000000000011         - 反码
//	0000 0000 0000 0000 0000 0000 0000 0011  - 补码
//	0    0    0    0    0    0    0    3     - 16进制(内存中)
//	
//	int b = -1;    //signed int b = -1;
//	10000000000000000000000000000001         - 原码
//	11111111111111111111111111111110         - 反码
//	1111 1111 1111 1111 1111 1111 1111 1111  - 补码
//	f    f    f    f    f    f    f    f     - 16进制(内存中)
//   
//	return 0;
//}

//int main()
//{
//	int c = 1 - 1;
//	//CPU只有加法器
//	//1 - 1 => 1 + (-1),此时用原码来进行计算，结果是错误的(-2)
//	//用补码来计算则可获得正确结果(符号位也参与计算,进位后丢掉即可)
//	
//	return 0;
//	
//
//}

//写一个代码，判断当前机器使用的大端还是小端
//int main()
//{
//	int a = 1;
//	char* p = (char*)&a;//对p解引用则访问一个字节 
//	if (*p == 1)
//	{
//		printf("小端");
//	}
//	else
//	{
//		printf("大端");
//	}
	//
	//0x 00 00 00 01
	//
	//低       高
	//小端  
	//01 00 00 00
	//大端
	//00 00 00 01

	//只需要看第一个字节是00还是01即可判断
//	return 0;
//}

//int check_sys()
//{
//	int a = 1;
//	return (*(char*)&a);
//}
//int main()
//{
//	int a = 1;
//	int ret = check_sys();
//	if (ret == 1)
//	{
//		printf("小端\n");
//	}
//	else
//	{
//		printf("大端\n");
//	}
//	return 0;
//}

//int main()
//{
//	char a = -1;
//	//大部分编译器基本上都是signed char
//	//11111111 - a
//	//11111111111111111111111111111111 - 整形提升后(此时是补码)
//	//10000000000000000000000000000001 - 原码  -1
//	signed char b = -1;
//	//11111111 - b 
//	//计算过程和a一样 -1
//	unsigned char c = -1;
//	//11111111 - c
//	//00000000000000000000000011111111 - 正数的原反补码都相同
//	//十进制 : 255
//
//	printf("a=%d,b=%d,c=%d", a, b, c);//a = -1, b = -1, c = 255
//	//打印%d时会发生整形提升(按照符号位提升)
//	return 0;
//}

//int main()
//{
//	char a = -128;
//	//10000000000000000000000010000000 - -128原码
//	//11111111111111111111111110000000 - -128补码
//	//1000000                          - 存到a中
//	//整形提升后:
//	//11111111111111111111111110000000 - 4294967168 (2^32 - 127 - 1)
//	//%u : 打印无符号整形
//	printf("a = %u\n", a); //a = 4294967168
//	return 0;
//}

//int main()
//{
//	char a = 128;
//	//00000000000000000000000010000000 - 128原码
//	//10000000                         - 存到a中
//	//整形提升后
//	//11111111111111111111111110000000 - 4294967168
//	printf("a = %u\n", a); // a = 4294967168
//	return 0;
//}

//int main()
//{
//	int i = -20;
//	//10000000000000000000000000010100 - -20原码
//	//11111111111111111111111111101100 - -20补码
//	unsigned  int  j = 10;
//	//00000000000000000000000000001010 -  10原(补)码
//	
//	//11111111111111111111111111110110 - i + j 补码
//	//10000000000000000000000000001010 - i + j 原码: -10
//	printf("i+j = %d\n", i + j); // i+j = -10
//	//按照补码的形式进行运算，最后格式化成为有符号整数
//}

//int main()
//{
//	unsigned int i;//因为i定义的是无符号类型 则始终有:i >= 0; 
//
//	for(i = 9; i >= 0; i--)
//	{
//		printf("%u\n", i); //死循环
//		//当i = -1存入内存中(之后以此类推):
//		//11111111111111111111111111111111 - 当做无符号数处理 - 一个巨大的正数
//	}
//	return 0;
//}

//int main()
//{
//	char a[1000];
//	int i;
//	for (i = 0; i < 1000; i++)
//	{
//		a[i] = -1 - i;
//	}
//	//a[i]从-1 -2 ... -128 共有128个数字
//	//对于char来说 负数最多到 : -128
//	//当存入-129时，对于char而言是放不下的
//	//10000000000000000000000010000001 - -129原码
//	//11111111111111111111111101111111 - -129补码
//	//01111111                         - -129存入char中 - 127
//	//以此类推,存入-130时,内存中实际存储的是126
//	//127 126 ... 3 2 1 0,0之前共有127个数字(因为strlen遇到0就终止了)
//	//127 + 128 = 255
//	printf("%d", strlen(a));//255
//	return 0;
//}

//unsigned char i = 0;
////对于无符号的char 取值范围是[0 , 255]
//int main()
//{
//	for (i = 0; i <= 255; i++)
//	{
//		printf("hello world\n");//死循环
//	}
//	return 0;
//}

//int main()
//{
//	char ch[1000] = {1,2,3,4,5,6,7,0};
//	printf("%d\n", strlen(ch));
//
//}

//int main()
//{
//	int n = 9;
//	float* pFloat = (float*)&n; //把int*类型指针强制转换成float*类型
//	printf("n的值为：%d\n", n); //9
//	printf("*pFloat的值为：%f\n", *pFloat);//0.000000
//	*pFloat = 9.0;
//	printf("n的值为：%d\n", n); //1091567616
//	printf("*pFloat的值为：%f\n", *pFloat); //9.000000
//	
//	return 0;
//}

//int main()
//{
//	float f = 5.5f;//如果不写f,则默认是double类型
//	//101.1
//	//1.011 * 2^2
//	//(-1)^0 * 1.011 * 2^2
//	//S = 0,E =10000001 (2 + 127),M = 011(后面再补20个0)
//	//0100 0000 1011 0000 0000 0000 0000 0000 - 内存中存储的二进制
//	//4    0    11   0    0    0    0    0    
//	//40 B0 00 00 - 十六进制
//
//	//E全为0
//	//0 00000000 01000100101000000000000
//	//E+127存入数据后是00000000
//	//真实的E = -127
//	//(-1)^0 * 1.01000100101 * 2^(-127) - 无限接近于0的数字
//	//所以对于接近0的数字:
//	//M拿出来不+1,E = -126(32位)
//	//(-1)^0 * 0.01000100101 * 2^(-126) - 真实取出时的数字，也无限接近于0
//
//	//E为全1
//	//E + 128 = 255
//	//E = 127
//	//(+ -) * 1.xxxxxx * 2 ^ 128 - 趋近于正负无限大
//
//	return 0;
//}

int main()
{
	int n = 9;
	//00000000000000000000000000001001 - 二进制

	float* pFloat = (float*)&n; //把int*类型指针强制转换成float*类型
	printf("n的值为：%d\n", n); //9
	
	printf("*pFloat的值为：%f\n", *pFloat);//0.000000
	//*pFloat - 以浮点数的视角去访问n的四个字节，就会认为n的4个字节中放的是浮点数
	//0 00000000 00000000000000000001001 (E全0的情况)
	//(-1)^0 * 2 ^ (-126) * 0.00000000000000000001001
	//0.000000
	
	*pFloat = 9.0;
	//*pFloat - 以浮点数的视角观察n的4个字节
	//以浮点数的形式存储9.0
	//1001.0 - 二进制
	//1.001 * 2^3 - 科学计数法
	//(-1)^0 * 1.001 * 2^3
	//S = 0,E = 130(3 + 127). M = 00100000000000000000000 
	//0 10000010 00100000000000000000000 - 内存中存储形式
	//1091567616 - 二进制
	printf("n的值为：%d\n", n); //1091567616
	printf("*pFloat的值为：%f\n", *pFloat); //9.000000

	return 0;
}